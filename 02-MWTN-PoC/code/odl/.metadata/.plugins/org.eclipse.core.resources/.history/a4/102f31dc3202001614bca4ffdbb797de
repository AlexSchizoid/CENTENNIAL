/*
* Copyright (c) 2016 Wipro Ltd. and others. All rights reserved.
*
* This program and the accompanying materials are made available under the
* terms of the Eclipse Public License v1.0 which accompanies this distribution,
* and is available at http://www.eclipse.org/legal/epl-v10.html
*/

package org.opendaylight.wtg.eventmanager.impl;

import org.opendaylight.controller.md.sal.binding.api.MountPoint;
import org.opendaylight.controller.md.sal.binding.api.MountPointService;
import org.opendaylight.controller.md.sal.binding.api.NotificationService;
import org.opendaylight.controller.sal.binding.api.BindingAwareBroker.ProviderContext;
import org.opendaylight.controller.sal.binding.api.BindingAwareProvider;
import org.opendaylight.controller.sal.binding.api.RpcConsumerRegistry;
import org.opendaylight.wtg.eventmanager.api.EventManagerService;
import org.opendaylight.wtg.eventmanager.impl.listener.MicrowaveEventListener;
import org.opendaylight.wtg.eventmanager.impl.xml.XmlMapper;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.netconf.notification._1._0.rev080714.CreateSubscriptionInputBuilder;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.netconf.notification._1._0.rev080714.NotificationsService;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.netconf.notification._1._0.rev080714.StreamNameType;
import org.opendaylight.controller.md.sal.binding.api.DataChangeListener;
import org.opendaylight.yang.gen.v1.urn.opendaylight.netconf.node.topology.rev150114.network.topology.topology.topology.types.TopologyNetconf;
import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.websocketmanager.rev150105.WebsocketmanagerService;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.NetworkTopology;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.NodeId;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.TopologyId;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.Topology;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.TopologyKey;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Node;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.NodeKey;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;
import org.opendaylight.controller.md.sal.common.api.data.AsyncDataBroker.DataChangeScope;
import org.opendaylight.controller.md.sal.common.api.data.AsyncDataChangeEvent;
import java.util.Map.Entry;
import org.opendaylight.yang.gen.v1.urn.opendaylight.netconf.node.topology.rev150114.NetconfNodeConnectionStatus.ConnectionStatus;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import org.opendaylight.yang.gen.v1.urn.opendaylight.netconf.node.topology.rev150114.NetconfNode;
import org.opendaylight.yang.gen.v1.urn.opendaylight.netconf.node.topology.rev150114.NetconfNodeConnectionStatus.ConnectionStatus;
import org.opendaylight.yangtools.concepts.ListenerRegistration;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Identifier;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;
import org.opendaylight.yangtools.yang.binding.KeyedInstanceIdentifier;
import org.opendaylight.yangtools.yang.common.QName;
import org.opendaylight.yangtools.yang.common.RpcResult;
import org.opendaylight.yangtools.yang.common.RpcResultBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.google.common.base.Optional;

//TODO
//Implement EventManagerService in another class
public class EventManagerImpl implements EventManagerService, BindingAwareProvider, AutoCloseable, DataChangeListener {

	private static final Logger LOG = LoggerFactory.getLogger(EventManagerImpl.class);
	private static final InstanceIdentifier<Topology> NETCONF_TOPO_IID = InstanceIdentifier
			.create(NetworkTopology.class)
			.child(Topology.class, new TopologyKey(new TopologyId(TopologyNetconf.QNAME.getLocalName())));
	private ProviderContext session;

	private WebsocketmanagerService websocketmanagerService;
	private XmlMapper xmlMapper;

	@Override
	public void onSessionInitiated(ProviderContext session) {
		LOG.info("EventManagerImpl Session Initiated");
		this.session = session;
		websocketmanagerService = session.getRpcService(WebsocketmanagerService.class);
		xmlMapper = new XmlMapper();
	}

	@Override
	public void close() throws Exception {
		LOG.info("EventManagerImpl closing");
	}

	@Override
	public void startListenerOnNode(String nodeName) {
		LOG.info("Starting Event listener on Netconf device :: Name : {}", nodeName);

		MountPointService mountService = session.getSALService(MountPointService.class);
		InstanceIdentifier<Node> instanceIdentifier = NETCONF_TOPO_IID.child(Node.class,
				new NodeKey(new NodeId(nodeName)));
		Optional<MountPoint> mountPoint = null;
		int timeout = 10000;

		do {
			mountPoint = mountService.getMountPoint(instanceIdentifier);
			LOG.info("Event listener waiting for mount point for Netconf device :: Name : {}", nodeName);
			try {
				Thread.sleep(1000);
				timeout -= 1000;
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		} while (!mountPoint.isPresent() && timeout > 0);

		if (timeout < 0) {
			LOG.warn("Event listener timeout while waiting for mount point for Netconf device :: Name : {} ", nodeName);
			return;
		}

		Optional<NotificationService> service1 = mountPoint.get().getService(NotificationService.class);

		MicrowaveEventListener microwaveEventListener = new MicrowaveEventListener(nodeName, websocketmanagerService,
				xmlMapper);
		service1.get().registerNotificationListener(microwaveEventListener);

		final String streamName = "NETCONF";
		final Optional<RpcConsumerRegistry> service = mountPoint.get().getService(RpcConsumerRegistry.class);
		final NotificationsService rpcService = service.get().getRpcService(NotificationsService.class);
		final CreateSubscriptionInputBuilder createSubscriptionInputBuilder = new CreateSubscriptionInputBuilder();
		createSubscriptionInputBuilder.setStream(new StreamNameType(streamName));
		LOG.info("Event listener triggering notification stream {} for node {}", streamName, nodeName);
		rpcService.createSubscription(createSubscriptionInputBuilder.build());
	}

	@Override
	public void removeListenerOnNode(String nodeName) {
		LOG.info("Removing Event listener on Netconf device :: Name : {}", nodeName);
		// ODL automatically removes
	}
	
	
    @Override
   public void onDataChanged(
           AsyncDataChangeEvent<InstanceIdentifier<?>, DataObject> change) {
       // We need to handle the following types of events:
       // 1. Discovery of new nodes
       // 2. Status change in existing nodes
       // 3. Removal of existing nodes
       LOG.info("OnDataChange, change: {}", change);

       // EXAMPLE: New node discovery
       // React to new Netconf nodes added to the Netconf topology or existing
       // Netconf nodes deleted from the Netconf topology
       for ( Entry<InstanceIdentifier<?>,
               DataObject> entry : change.getCreatedData().entrySet()) {
           if (entry.getKey().getTargetType() == NetconfNode.class) {
               NodeId nodeId = getNodeId(entry.getKey());
               LOG.info("NETCONF Node: {} was created", nodeId.getValue());

               // Not much can be done at this point, we need UPDATE event with
               // state set to connected
           }
       }

       // EXAMPLE: Status change in existing node(s)
       // React to data changes in Netconf nodes that are present in the
       // Netconf topology
       for ( Entry<InstanceIdentifier<?>,
               DataObject> entry : change.getUpdatedData().entrySet()) {
           if (entry.getKey().getTargetType() == NetconfNode.class) {
               NodeId nodeId = getNodeId(entry.getKey());

               // We have a Netconf device
               NetconfNode nnode = (NetconfNode)entry.getValue();
               ConnectionStatus csts = nnode.getConnectionStatus();

               switch (csts) {
                   case Connected: {
                       // Fully connected, all services for remote device are
                       // available from the MountPointService.
                       LOG.info("NETCONF Node: {} is fully connected", nodeId.getValue());
                       List<String> capabilities =
                               nnode.getAvailableCapabilities().getAvailableCapability();
                       LOG.info("Capabilities: {}", capabilities);

                       // Assuming mediator has the capability to send notifications. Registering for events
                       startListenerOnNode(nodeId.getValue());

                       break;
                   }
                   case Connecting: {
                       // A Netconf device's will be in the 'Connecting' state
                       // initially, and go back to it after disconnect.
                       // Note that a device could be moving back and forth
                       // between the 'Connected' and 'Connecting' states for
                       // various reasons, such as disconnect from remote
                       // device, network connectivity loss etc.
                       LOG.info("NETCONF Node: {} was disconnected", nodeId.getValue());
                       break;
                   }
                   case UnableToConnect: {
                       // The maximum configured number of reconnect attempts
                       // have been reached. No more reconnects will be
                       // attempted by the Netconf Connector.
                       LOG.info("NETCONF Node: {} connection failed", nodeId.getValue());
                       break;
                   }
               }
           }
       }	
       
       // EXAMPLE: Removal of an existing node from the Netconf topology
       for (InstanceIdentifier<?> removedPath : change.getRemovedPaths()) {
           final NodeId nodeId = getNodeId(removedPath);
           if (nodeId != null) {
               // A User removed the Netconf connector for this node
               // Before a node is removed, it changes its state to connecting
               // (just as if it was disconnected). We may see this multiple
               // times, since our listener is scoped to SUBTREE.
               LOG.info("NETCONF Node: {} was removed", nodeId.getValue());
           }
       }
    }
    private NodeId getNodeId(final InstanceIdentifier<?> path) {
        for (InstanceIdentifier.PathArgument pathArgument : path.getPathArguments()) {
            if (pathArgument instanceof InstanceIdentifier.IdentifiableItem<?, ?>) {

                final Identifier key = ((InstanceIdentifier.IdentifiableItem) pathArgument).getKey();
                if(key instanceof NodeKey) {
                    return ((NodeKey) key).getNodeId();
                }
            }
        }
        return null;
    }
}
