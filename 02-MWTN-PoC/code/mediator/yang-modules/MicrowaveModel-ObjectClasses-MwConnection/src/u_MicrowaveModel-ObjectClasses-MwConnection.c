
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.5-5

    User SIL module
    module MicrowaveModel-ObjectClasses-MwConnection
    revision 2016-03-23
    namespace uri:onf:MicrowaveModel-ObjectClasses-MwConnection

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "u_MicrowaveModel-ObjectClasses-MwConnection.h"
#include "y_MicrowaveModel-ObjectClasses-MwConnection.h"

#include "../utils/utils.h"

/* put your static variables here */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_layerProtocol_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/layerProtocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_layerProtocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_layerProtocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_layerProtocol_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/airInterfaceID
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    const xmlChar *airInterfaceID;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID_get callback");
    }


    /* set the airInterfaceID var here, change EMPTY_STRING */
    airInterfaceID = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        airInterfaceID);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_typeOfEquipment_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/typeOfEquipment
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_typeOfEquipment_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    const xmlChar *typeOfEquipment;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_typeOfEquipment_get callback");
    }


    /* set the typeOfEquipment var here, change EMPTY_STRING */
    typeOfEquipment = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        typeOfEquipment);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_typeOfEquipment_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_supportedChannelPlans_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/supportedChannelPlans
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_supportedChannelPlans_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    const xmlChar *supportedChannelPlans;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_supportedChannelPlans_get callback");
    }


    /* set the supportedChannelPlans var here, change EMPTY_STRING */
    supportedChannelPlans = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        supportedChannelPlans);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_supportedChannelPlans_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMin_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/txFrequencyMin
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMin_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    uint64 txFrequencyMin;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMin_get callback");
    }


    /* set the txFrequencyMin var here, change zero */
    txFrequencyMin = 0;
    VAL_ULONG(dstval) = txFrequencyMin;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMin_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMax_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/txFrequencyMax
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMax_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    uint64 txFrequencyMax;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMax_get callback");
    }


    /* set the txFrequencyMax var here, change zero */
    txFrequencyMax = 0;
    VAL_ULONG(dstval) = txFrequencyMax;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_txFrequencyMax_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMin_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/rxFrequencyMin
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMin_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    uint64 rxFrequencyMin;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMin_get callback");
    }


    /* set the rxFrequencyMin var here, change zero */
    rxFrequencyMin = 0;
    VAL_ULONG(dstval) = rxFrequencyMin;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMin_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMax_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/rxFrequencyMax
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMax_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    uint64 rxFrequencyMax;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMax_get callback");
    }


    /* set the rxFrequencyMax var here, change zero */
    rxFrequencyMax = 0;
    VAL_ULONG(dstval) = rxFrequencyMax;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_rxFrequencyMax_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_adaptiveModulationIsAvail_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/adaptiveModulationIsAvail
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_adaptiveModulationIsAvail_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID)
{
    status_t res = NO_ERR;
    boolean adaptiveModulationIsAvail;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_adaptiveModulationIsAvail_get callback");
    }


    /* set the adaptiveModulationIsAvail var here, change TRUE if needed */
    adaptiveModulationIsAvail = TRUE;VAL_BOOL(dstval) = adaptiveModulationIsAvail;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_adaptiveModulationIsAvail_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/scriptList/scriptID
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID)
{
    status_t res = NO_ERR;
    const xmlChar *scriptID;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID_get callback");
    }


    /* set the scriptID var here, change EMPTY_STRING */
    scriptID = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        scriptID);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_channelBandwidth_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/scriptList/channelBandwidth
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_channelBandwidth_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID)
{
    status_t res = NO_ERR;
    uint64 channelBandwidth;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_channelBandwidth_get callback");
    }


    /* set the channelBandwidth var here, change zero */
    channelBandwidth = 0;
    VAL_ULONG(dstval) = channelBandwidth;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_channelBandwidth_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_modulationScheme_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/scriptList/modulationScheme
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_modulationScheme_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID)
{
    status_t res = NO_ERR;
    uint64 modulationScheme;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_modulationScheme_get callback");
    }


    /* set the modulationScheme var here, change zero */
    modulationScheme = 0;
    VAL_ULONG(dstval) = modulationScheme;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_modulationScheme_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMin_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/scriptList/txPowerMin
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMin_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID)
{
    status_t res = NO_ERR;
    int64 txPowerMin;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMin_get callback");
    }


    /* set the txPowerMin var here, change zero */
    txPowerMin = 0;
    VAL_LONG(dstval) = txPowerMin;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMin_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMax_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/scriptList/txPowerMax
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMax_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID)
{
    status_t res = NO_ERR;
    int64 txPowerMax;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMax_get callback");
    }


    /* set the txPowerMax var here, change zero */
    txPowerMax = 0;
    VAL_LONG(dstval) = txPowerMax;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_txPowerMax_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_xpicIsAvail_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCapabilityList/scriptList/xpicIsAvail
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_xpicIsAvail_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_airInterfaceID,
    const xmlChar *k_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_scriptID)
{
    status_t res = NO_ERR;
    boolean xpicIsAvail;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_xpicIsAvail_get callback");
    }


    /* set the xpicIsAvail var here, change TRUE if needed */
    xpicIsAvail = TRUE;VAL_BOOL(dstval) = xpicIsAvail;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCapabilityList_scriptList_xpicIsAvail_get */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_airInterfaceName_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/airInterfaceName
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_airInterfaceName_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_airInterfaceName_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_air_interface_name(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
    	YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
    			newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_airInterfaceName_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_radioSignalId_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/radioSignalId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_radioSignalId_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_radioSignalId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_radio_signal_id(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
				newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_radioSignalId_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txFrequency_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/txFrequency
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txFrequency_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txFrequency_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_tx_frequency(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
				newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txFrequency_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxFrequency_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/rxFrequency
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxFrequency_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxFrequency_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_rx_frequency(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxFrequency_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txChannelBandwidth_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/txChannelBandwidth
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txChannelBandwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txChannelBandwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_tx_channel_bandwidth(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txChannelBandwidth_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxChannelBandwidth_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/rxChannelBandwidth
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxChannelBandwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxChannelBandwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_rx_channel_bandwidth(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_rxChannelBandwidth_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_powerIsOn_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/powerIsOn
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_powerIsOn_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_powerIsOn_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_power_is_on(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_powerIsOn_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_transmitterIsOn_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/transmitterIsOn
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_transmitterIsOn_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_transmitterIsOn_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_transmitter_is_on(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_transmitterIsOn_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txPower_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/txPower
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txPower_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txPower_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_tx_power(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_txPower_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_adaptiveModulationIsOn_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/adaptiveModulationIsOn
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_adaptiveModulationIsOn_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_adaptiveModulationIsOn_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_adaptive_modulation_is_on(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_adaptiveModulationIsOn_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMin_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/modulationMin
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMin_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMin_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_modulation_min(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMin_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMax_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/modulationMax
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMax_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMax_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_modulation_max(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_modulationMax_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_xpicIsOn_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration/xpicIsOn
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_xpicIsOn_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_xpicIsOn_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_air_interface_configuration_xpic_is_on(k_MW_AirInterface_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_AirInterface_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_xpicIsOn_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac/airInterfaceConfiguration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceConfiguration_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txFrequencyCur_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceStatus/txFrequencyCur
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txFrequencyCur_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    uint64 txFrequencyCur;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txFrequencyCur_get callback");
    }

    res = cb_get_air_interface_status_tx_frequency_cur(k_MW_AirInterface_Pac_layerProtocol, &txFrequencyCur);
    YUMA_ASSERT(res != NO_ERR, txFrequencyCur = 0, "Could not fetch value!");

    /* set the txFrequencyCur var here, change zero */
    VAL_ULONG(dstval) = txFrequencyCur;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txFrequencyCur_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxFrequencyCur_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceStatus/rxFrequencyCur
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxFrequencyCur_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    uint64 rxFrequencyCur;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxFrequencyCur_get callback");
    }

    res = cb_get_air_interface_status_rx_frequency_cur(k_MW_AirInterface_Pac_layerProtocol, &rxFrequencyCur);
    YUMA_ASSERT(res != NO_ERR, rxFrequencyCur = 0, "Could not fetch value!");

    /* set the rxFrequencyCur var here, change zero */
    VAL_ULONG(dstval) = rxFrequencyCur;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxFrequencyCur_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txLevelCur_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceStatus/txLevelCur
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txLevelCur_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    int64 txLevelCur;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txLevelCur_get callback");
    }

    res = cb_get_air_interface_status_tx_level_cur(k_MW_AirInterface_Pac_layerProtocol, &txLevelCur);
    YUMA_ASSERT(res != NO_ERR, txLevelCur = 0, "Could not fetch value!");

    /* set the txLevelCur var here, change zero */
    VAL_LONG(dstval) = txLevelCur;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_txLevelCur_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxLevelCur_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceStatus/rxLevelCur
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxLevelCur_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    int64 rxLevelCur;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxLevelCur_get callback");
    }

    res = cb_get_air_interface_status_tx_level_cur(k_MW_AirInterface_Pac_layerProtocol, &rxLevelCur);
    YUMA_ASSERT(res != NO_ERR, rxLevelCur = 0, "Could not fetch value!");

    /* set the rxLevelCur var here, change zero */
    VAL_LONG(dstval) = rxLevelCur;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_rxLevelCur_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_snrCur_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceStatus/snrCur
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_snrCur_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    int64 snrCur;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_snrCur_get callback");
    }

    res = cb_get_air_interface_status_snr_cur(k_MW_AirInterface_Pac_layerProtocol, &snrCur);
    YUMA_ASSERT(res != NO_ERR, snrCur = 0, "Could not fetch value!");

    /* set the snrCur var here, change zero */
    VAL_LONG(dstval) = snrCur;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_snrCur_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_linkIsUp_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceStatus/linkIsUp
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_linkIsUp_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    boolean linkIsUp;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_linkIsUp_get callback");
    }

    res = cb_get_air_interface_status_link_is_up(k_MW_AirInterface_Pac_layerProtocol, &linkIsUp);
    YUMA_ASSERT(res != NO_ERR, linkIsUp = TRUE, "Could not fetch value!");

    /* set the linkIsUp var here, change TRUE if needed */
    VAL_BOOL(dstval) = linkIsUp;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_linkIsUp_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_xpicIsUp_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceStatus/xpicIsUp
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_xpicIsUp_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    boolean xpicIsUp;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_xpicIsUp_get callback");
    }

    res = cb_get_air_interface_status_xpic_is_up(k_MW_AirInterface_Pac_layerProtocol, &xpicIsUp);
    YUMA_ASSERT(res != NO_ERR, xpicIsUp = TRUE, "Could not fetch value!");

    /* set the xpicIsUp var here, change TRUE if needed */
    VAL_BOOL(dstval) = xpicIsUp;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceStatus_xpicIsUp_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCurrentProblemList_problemList_get
* 
* Get database object callback
* Path: /MW_AirInterface_Pac/airInterfaceCurrentProblemList/problemList
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCurrentProblemList_problemList_get (
    val_value_t *dstval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    const xmlChar *problemList;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCurrentProblemList_problemList_get callback");
    }


    /* set the problemList var here, change EMPTY_STRING */
    problemList = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        problemList);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_airInterfaceCurrentProblemList_problemList_get */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_edit
* 
* Edit database object callback
* Path: /MW_AirInterface_Pac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_AirInterface_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_layerProtocol_edit
* 
* Edit database object callback
* Path: /MW_Structure_Pac/layerProtocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_layerProtocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_layerProtocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_layerProtocol_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_structureID_get
* 
* Get database object callback
* Path: /MW_Structure_Pac/structureCapability/structureID
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_structureID_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    const xmlChar *structureID;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_structureID_get callback");
    }


    /* set the structureID var here, change EMPTY_STRING */
    res = cb_get_structure_capability_structure_id(k_MW_Structure_Pac_layerProtocol, &structureID);
    YUMA_ASSERT(res != NO_ERR, structureID = EMPTY_STRING, "Could not fetch object!");

    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        structureID);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_structureID_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_totalNumberOfTimeSlots_get
* 
* Get database object callback
* Path: /MW_Structure_Pac/structureCapability/totalNumberOfTimeSlots
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_totalNumberOfTimeSlots_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    uint64 totalNumberOfTimeSlots;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_totalNumberOfTimeSlots_get callback");
    }

    res = cb_get_structure_capability_total_number_of_timeslots(k_MW_Structure_Pac_layerProtocol, &totalNumberOfTimeSlots);
    YUMA_ASSERT(res != NO_ERR, totalNumberOfTimeSlots = 0, "Could not fetch object!");


    /* set the totalNumberOfTimeSlots var here, change zero */

    VAL_ULONG(dstval) = totalNumberOfTimeSlots;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_totalNumberOfTimeSlots_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_timeSlotCapacity_get
* 
* Get database object callback
* Path: /MW_Structure_Pac/structureCapability/timeSlotCapacity
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_timeSlotCapacity_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    uint64 timeSlotCapacity;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_timeSlotCapacity_get callback");
    }

    res = cb_get_structure_capability_time_slot_capacity(k_MW_Structure_Pac_layerProtocol, &timeSlotCapacity);
    YUMA_ASSERT(res != NO_ERR, timeSlotCapacity = 0, "Could not fetch object!");


    /* set the timeSlotCapacity var here, replace (void) or use default value */
    VAL_ULONG(dstval) = timeSlotCapacity;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureCapability_timeSlotCapacity_get */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_serverID_edit
* 
* Edit database object callback
* Path: /MW_Structure_Pac/structureConfiguration/serverID
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_serverID_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_serverID_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_structure_configuration_server_id(k_MW_Structure_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_Structure_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_serverID_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_edit
* 
* Edit database object callback
* Path: /MW_Structure_Pac/structureConfiguration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureConfiguration_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_structureID_get
* 
* Get database object callback
* Path: /MW_Structure_Pac/structureStatus/timeSlotStatusList/structureID
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_structureID_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol,
    const xmlChar *k_MW_Structure_Pac_structureStatus_timeSlotStatusList_structureID,
    const xmlChar *k_MW_Structure_Pac_structureStatus_timeSlotStatusList_timeSlotID)
{
    status_t res = NO_ERR;
    const xmlChar *structureID;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_structureID_get callback");
    }


    /* set the structureID var here, change EMPTY_STRING */
    structureID = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        structureID);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_structureID_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_timeSlotID_get
* 
* Get database object callback
* Path: /MW_Structure_Pac/structureStatus/timeSlotStatusList/timeSlotID
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_timeSlotID_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol,
    const xmlChar *k_MW_Structure_Pac_structureStatus_timeSlotStatusList_structureID,
    const xmlChar *k_MW_Structure_Pac_structureStatus_timeSlotStatusList_timeSlotID)
{
    status_t res = NO_ERR;
    const xmlChar *timeSlotID;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_timeSlotID_get callback");
    }


    /* set the timeSlotID var here, change EMPTY_STRING */
    timeSlotID = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        timeSlotID);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_timeSlotID_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_operationalStatus_get
* 
* Get database object callback
* Path: /MW_Structure_Pac/structureStatus/timeSlotStatusList/operationalStatus
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_operationalStatus_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol,
    const xmlChar *k_MW_Structure_Pac_structureStatus_timeSlotStatusList_structureID,
    const xmlChar *k_MW_Structure_Pac_structureStatus_timeSlotStatusList_timeSlotID)
{
    status_t res = NO_ERR;
    const xmlChar *operationalStatus;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_operationalStatus_get callback");
    }


    /* set the operationalStatus var here, change enum */
    operationalStatus = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        operationalStatus);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_structureStatus_timeSlotStatusList_operationalStatus_get */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_edit
* 
* Edit database object callback
* Path: /MW_Structure_Pac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Structure_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_layerProtocol_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac/layerProtocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_layerProtocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_layerProtocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_layerProtocol_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_containerID_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerCapability/containerID
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_containerID_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    const xmlChar *containerID;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_containerID_get callback");
    }


    /* set the containerID var here, change EMPTY_STRING */
    containerID = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        containerID);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_containerID_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerCapability/availableKindsOfContainerList/uuid
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol,
    const xmlChar *k_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid)
{
    status_t res = NO_ERR;
    const xmlChar *uuid;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid_get callback");
    }


    /* set the uuid var here, change EMPTY_STRING */
    uuid = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        uuid);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_containerName_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerCapability/availableKindsOfContainerList/containerName
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_containerName_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol,
    const xmlChar *k_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid)
{
    status_t res = NO_ERR;
    const xmlChar *containerName;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_containerName_get callback");
    }


    /* set the containerName var here, change EMPTY_STRING */
    containerName = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        containerName);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_containerName_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_numberOfTimeSlotsRequired_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerCapability/availableKindsOfContainerList/numberOfTimeSlotsRequired
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_numberOfTimeSlotsRequired_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol,
    const xmlChar *k_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid)
{
    status_t res = NO_ERR;
    uint64 numberOfTimeSlotsRequired;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_numberOfTimeSlotsRequired_get callback");
    }


    /* set the numberOfTimeSlotsRequired var here, change zero */
    numberOfTimeSlotsRequired = 0;
    VAL_ULONG(dstval) = numberOfTimeSlotsRequired;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_numberOfTimeSlotsRequired_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_bundlingIsAvail_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerCapability/availableKindsOfContainerList/bundlingIsAvail
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_bundlingIsAvail_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol,
    const xmlChar *k_MW_Container_Pac_containerCapability_availableKindsOfContainerList_uuid)
{
    status_t res = NO_ERR;
    boolean bundlingIsAvail;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_bundlingIsAvail_get callback");
    }


    /* set the bundlingIsAvail var here, change TRUE if needed */
    bundlingIsAvail = TRUE;VAL_BOOL(dstval) = bundlingIsAvail;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerCapability_availableKindsOfContainerList_bundlingIsAvail_get */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_uuid_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac/containerConfiguration/container/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_set_container_configuration_uuid(k_MW_Container_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_Container_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_uuid_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_containerName_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerConfiguration/container/containerName
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_containerName_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    const xmlChar *containerName;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_containerName_get callback");
    }


    /* set the containerName var here, change EMPTY_STRING */
    containerName = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        containerName);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_containerName_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_numberOfTimeSlotsRequired_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerConfiguration/container/numberOfTimeSlotsRequired
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_numberOfTimeSlotsRequired_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    uint64 numberOfTimeSlotsRequired;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_numberOfTimeSlotsRequired_get callback");
    }


    /* set the numberOfTimeSlotsRequired var here, change zero */
    numberOfTimeSlotsRequired = 0;
    VAL_ULONG(dstval) = numberOfTimeSlotsRequired;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_numberOfTimeSlotsRequired_get */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_bundlingIsAvail_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerConfiguration/container/bundlingIsAvail
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_bundlingIsAvail_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    boolean bundlingIsAvail;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_bundlingIsAvail_get callback");
    }


    /* set the bundlingIsAvail var here, change TRUE if needed */
    bundlingIsAvail = TRUE;VAL_BOOL(dstval) = bundlingIsAvail;

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_bundlingIsAvail_get */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac/containerConfiguration/container
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_container_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_structureID_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac/containerConfiguration/timeSlotIDList/structureID
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_structureID_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol,
    const xmlChar *k_MW_Container_Pac_containerConfiguration_timeSlotIDList_structureID,
    const xmlChar *k_MW_Container_Pac_containerConfiguration_timeSlotIDList_timeSlotID)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_structureID_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_structureID_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_timeSlotID_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac/containerConfiguration/timeSlotIDList/timeSlotID
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_timeSlotID_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol,
    const xmlChar *k_MW_Container_Pac_containerConfiguration_timeSlotIDList_structureID,
    const xmlChar *k_MW_Container_Pac_containerConfiguration_timeSlotIDList_timeSlotID)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_timeSlotID_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_timeSlotID_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac/containerConfiguration/timeSlotIDList
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol,
    const xmlChar *k_MW_Container_Pac_containerConfiguration_timeSlotIDList_structureID,
    const xmlChar *k_MW_Container_Pac_containerConfiguration_timeSlotIDList_timeSlotID)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
    	res = cb_get_all_container_capabilities_available_kinds_of_containers_keys_for_layer_protocol_key(k_MW_Container_Pac_layerProtocol, newval->v.str);
		YUMA_ASSERT(res != NO_ERR, return ERR_INTERNAL_VAL, "Could not set the value=%s for object=%s having the key=%s",
		newval->v.str, newval->name, k_MW_Container_Pac_layerProtocol);

        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_timeSlotIDList_edit */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac/containerConfiguration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerConfiguration_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerStatus_get
* 
* Get database object callback
* Path: /MW_Container_Pac/containerStatus
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerStatus_get (
    val_value_t *dstval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;
    const xmlChar *containerStatus;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerStatus_get callback");
    }


    /* set the containerStatus var here, change EMPTY_STRING */
    res = cb_get_container_status(k_MW_Container_Pac_layerProtocol, &containerStatus);
    YUMA_ASSERT(res != NO_ERR, containerStatus = EMPTY_STRING, "Could not fetch value for object!");

    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        containerStatus);

    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_containerStatus_get */


/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_edit
* 
* Edit database object callback
* Path: /MW_Container_Pac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_MW_Container_Pac_layerProtocol)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_edit */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_init
* 
* initialize the MicrowaveModel-ObjectClasses-MwConnection server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    ncx_module_t *MicrowaveModel_ObjectClasses_MwConnection_mod = NULL;
    MicrowaveModel_ObjectClasses_MwConnection_mod = ncx_find_module(
        y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
        y_MicrowaveModel_ObjectClasses_MwConnection_R_MicrowaveModel_ObjectClasses_MwConnection);
    if (MicrowaveModel_ObjectClasses_MwConnection_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }
    /* put your module initialization code here */
    
    return res;
} /* u_MicrowaveModel_ObjectClasses_MwConnection_init */

static status_t u_find_and_init_child_obj(const xmlChar *modname, const xmlChar *objname,
		val_value_t *parent_val, val_value_t **child_val, const xmlChar *valuestr)
{
	status_t 		res = NO_ERR;
	obj_template_t* child_obj;

	YUMA_ASSERT(child_val == NULL, return SET_ERROR(ERR_INTERNAL_VAL), "**child_val for %s is NULL!", objname);

	child_obj = obj_find_child(parent_val->obj, modname, objname);
	YUMA_ASSERT(child_obj == NULL, return SET_ERROR(ERR_INTERNAL_VAL), "Could not find object %s!", objname);

	*child_val = val_new_value();
	YUMA_ASSERT(*child_val == NULL, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create object %s!", objname);

	val_init_from_template(*child_val, child_obj);

	if (valuestr != NULL)
	{
		res = val_set_simval_obj(*child_val, child_obj, valuestr);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "val_set_simval_obj %s failed!", objname);
	}

	val_add_child(*child_val, parent_val);

	if (obj_is_key(child_obj))
	{
		res = val_gen_key_entry(*child_val);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "val_gen_key_entry failed for %s!", objname);
	}

	return NO_ERR;
}

static status_t attach_air_interface_configuration_element_for_key(val_value_t *parent_val, const xmlChar* air_interface_pac_key)
{
	status_t res = NO_ERR;

	/*
	 * Create airInterfaceConfiguration container
	 */
	val_value_t*		airInterfaceConfiguration_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceConfiguration,
									parent_val,
									&airInterfaceConfiguration_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceConfiguration);


	/*
	 * Create airInterfaceName leaf
	 */
	val_value_t*		airInterfaceName_val;

	xmlChar* air_interface_name;
	res = cb_get_air_interface_configuration_air_interface_name(air_interface_pac_key, &air_interface_name);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_air_interface_name failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceName,
									airInterfaceConfiguration_val,
									&airInterfaceName_val,
									air_interface_name);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceName);

	/*
	 * Create radioSignalId leaf
	 */
	val_value_t*		radioSignalId_val;

	xmlChar* radio_signal_id;
	res = cb_get_air_interface_configuration_radio_signal_id(air_interface_pac_key, &radio_signal_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_radio_signal_id failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_radioSignalId,
									airInterfaceConfiguration_val,
									&radioSignalId_val,
									radio_signal_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_radioSignalId);

	/*
	 * Create txFrequency leaf
	 */
	val_value_t*		txFrequency_val;

	xmlChar* tx_frequency_string;
	res = cb_get_air_interface_configuration_tx_frequency(air_interface_pac_key, &tx_frequency_string);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_tx_frequency failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_txFrequency,
									airInterfaceConfiguration_val,
									&txFrequency_val,
									tx_frequency_string);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_txFrequency);

	/*
	 * Create rxFrequency leaf
	 */
	val_value_t*		rxFrequency_val;

	xmlChar* rx_frequency_string;
	res = cb_get_air_interface_configuration_rx_frequency(air_interface_pac_key, &rx_frequency_string);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_rx_frequency failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_rxFrequency,
									airInterfaceConfiguration_val,
									&rxFrequency_val,
									rx_frequency_string);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_rxFrequency);

	/*
	 * Create txChannelBandwidth leaf
	 */
	val_value_t*		txChannelBandwidth_val;

	xmlChar* tx_channel_bandwidth;
	res = cb_get_air_interface_configuration_tx_channel_bandwidth(air_interface_pac_key, &tx_channel_bandwidth);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_tx_channel_bandwidth failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_txChannelBandwidth,
									airInterfaceConfiguration_val,
									&txChannelBandwidth_val,
									tx_channel_bandwidth);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_txChannelBandwidth);

	/*
	 * Create rxChannelBandwidth leaf
	 */
	val_value_t*		rxChannelBandwidth_val;

	xmlChar* rx_channel_bandwidth;
	res = cb_get_air_interface_configuration_rx_channel_bandwidth(air_interface_pac_key, &rx_channel_bandwidth);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_rx_channel_bandwidth failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_rxChannelBandwidth,
									airInterfaceConfiguration_val,
									&rxChannelBandwidth_val,
									rx_channel_bandwidth);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_rxChannelBandwidth);

	/*
	 * Create powerIsOn leaf
	 */
	val_value_t*		powerIsOn_val;

	xmlChar* power_is_on;
	res = cb_get_air_interface_configuration_power_is_on(air_interface_pac_key, &power_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_power_is_on failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_powerIsOn,
									airInterfaceConfiguration_val,
									&powerIsOn_val,
									power_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_powerIsOn);

	/*
	 * Create transmitterIsOn leaf
	 */
	val_value_t*		transmitterIsOn_val;

	xmlChar* transmitter_is_on;
	res = cb_get_air_interface_configuration_transmitter_is_on(air_interface_pac_key, &transmitter_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_transmitter_is_on failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_transmitterIsOn,
									airInterfaceConfiguration_val,
									&transmitterIsOn_val,
									transmitter_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_transmitterIsOn);

	/*
	 * Create txPower leaf
	 */
	val_value_t*		txPower_val;

	xmlChar* tx_power;
	res = cb_get_air_interface_configuration_tx_power(air_interface_pac_key, &tx_power);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_tx_power failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_txPower,
									airInterfaceConfiguration_val,
									&txPower_val,
									tx_power);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_txPower);

	/*
	 * Create adaptiveModulationIsOn leaf
	 */
	val_value_t*		adaptiveModulationIsOn_val;

	xmlChar* adaptive_modulation_is_on;
	res = cb_get_air_interface_configuration_adaptive_modulation_is_on(air_interface_pac_key, &adaptive_modulation_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_adaptive_modulation_is_on failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_adaptiveModulationIsOn,
									airInterfaceConfiguration_val,
									&adaptiveModulationIsOn_val,
									adaptive_modulation_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_adaptiveModulationIsOn);

	/*
	 * Create modulationMin leaf
	 */
	val_value_t*		modulationMin_val;

	xmlChar* modulation_min;
	res = cb_get_air_interface_configuration_modulation_min(air_interface_pac_key, &modulation_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_modulation_min failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_modulationMin,
									airInterfaceConfiguration_val,
									&modulationMin_val,
									modulation_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_modulationMin);

	/*
	 * Create modulationMax leaf
	 */
	val_value_t*		modulationMax_val;

	xmlChar* modulation_max;
	res = cb_get_air_interface_configuration_modulation_max(air_interface_pac_key, &modulation_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_modulation_max failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_modulationMax,
									airInterfaceConfiguration_val,
									&modulationMax_val,
									modulation_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_modulationMax);

	/*
	 * Create xpicIsOn leaf
	 */
	val_value_t*		xpicIsOn_val;

	xmlChar* xpic_is_on;
	res = cb_get_air_interface_configuration_xpic_is_on(air_interface_pac_key, &xpic_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_configuration_xpic_is_on failed for key %s!", air_interface_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_xpicIsOn,
									airInterfaceConfiguration_val,
									&xpicIsOn_val,
									xpic_is_on);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_xpicIsOn);

	return NO_ERR;
}

static status_t attach_air_interface_capabilities_script_list_entry(val_value_t* parent_val, xmlChar* air_interface_capability_script_list_key)
{
	status_t 			res = NO_ERR;

	/*
	 * Create scriptList list entry
	 */
	val_value_t*		scriptList_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_scriptList,
									parent_val,
									&scriptList_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_scriptList);

	/*
	 * Create scriptID leaf
	 */
	val_value_t*		scriptID_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_scriptID,
									scriptList_val,
									&scriptID_val,
									air_interface_capability_script_list_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_scriptID);

	/*
	 * Create channelBandwidth leaf
	 */
	val_value_t*		channelBandwidth_val;

	xmlChar* channel_bandwidth;
	res = cb_get_air_interface_capabilities_script_channel_bandwidth(air_interface_capability_script_list_key, &channel_bandwidth);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_script_channel_bandwidth failed for key %s!", air_interface_capability_script_list_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_channelBandwidth,
									scriptList_val,
									&channelBandwidth_val,
									channel_bandwidth);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_channelBandwidth);

	/*
	 * Create modulationScheme leaf
	 */
	val_value_t*		modulationScheme_val;

	xmlChar* modulation_scheme;
	res = cb_get_air_interface_capabilities_script_modulation_scheme(air_interface_capability_script_list_key, &modulation_scheme);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_script_modulation_scheme failed for key %s!", air_interface_capability_script_list_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_modulationScheme,
									scriptList_val,
									&modulationScheme_val,
									modulation_scheme);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_modulationScheme);

	/*
	 * Create txPowerMin leaf
	 */
	val_value_t*		txPowerMin_val;

	xmlChar* tx_power_min;
	res = cb_get_air_interface_capabilities_script_tx_power_min(air_interface_capability_script_list_key, &tx_power_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_script_tx_power_min failed for key %s!", air_interface_capability_script_list_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_txPowerMin,
									scriptList_val,
									&txPowerMin_val,
									tx_power_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_txPowerMin);

	/*
	 * Create txPowerMax leaf
	 */
	val_value_t*		txPowerMax_val;

	xmlChar* tx_power_max;
	res = cb_get_air_interface_capabilities_script_tx_power_max(air_interface_capability_script_list_key, &tx_power_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_script_tx_power_max failed for key %s!", air_interface_capability_script_list_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_txPowerMax,
									scriptList_val,
									&txPowerMax_val,
									tx_power_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_txPowerMax);

	/*
	 * Create xpicIsAvail leaf
	 */
	val_value_t*		xpicIsAvail_val;

	xmlChar* xpic_is_avail;
	res = cb_get_air_interface_capabilities_script_xpic_is_avail(air_interface_capability_script_list_key, &xpic_is_avail);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_script_xpic_is_avail failed for key %s!", air_interface_capability_script_list_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_xpicIsAvail,
									scriptList_val,
									&xpicIsAvail_val,
									xpic_is_avail);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_xpicIsAvail);

	return NO_ERR;
}

static status_t attach_air_interface_capabilities_script_list(val_value_t *parent_val)
{
	status_t 			res = NO_ERR;

	xmlChar* air_interface_capability_script_list_key_list[MAX_NUMBER_OF_SCRIPT_LIST_KEYS];
	int num_of_keys;
	int i;

	/*
	 * Create scriptList list element entry for each available scriptID
	 */

	res = cb_get_all_air_interface_capability_script_list_keys(air_interface_capability_script_list_key_list, &num_of_keys);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not cb_get_all_air_interface_capability_script_list_keys!");

	for (i=0; i<num_of_keys; ++i)
	{
		res = attach_air_interface_capabilities_script_list_entry(parent_val, air_interface_capability_script_list_key_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not add interface capabilities entry!");
	}

	return NO_ERR;
}

static status_t add_air_interface_capabilities_entry(val_value_t* parent_val, xmlChar* air_interface_capabilities_key)
{
	status_t 			res = NO_ERR;

	/*
	 * Create airInterfaceCapabilityList list parent element
	 */
	val_value_t*		airInterfaceCapabilityList_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceCapabilityList,
									parent_val,
									&airInterfaceCapabilityList_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceCapabilityList);

	/*
	 * Create airInterfaceID leaf
	 */
	val_value_t*		airInterfaceID_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceID,
									airInterfaceCapabilityList_val,
									&airInterfaceID_val,
									air_interface_capabilities_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceID);

	/*
	 * Create typeOfEquipment leaf
	 */
	val_value_t*		typeOfEquipment_val;

	xmlChar* type_of_equipment;
	res = cb_get_air_interface_capabilities_type_of_equipment(air_interface_capabilities_key, &type_of_equipment);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_type_of_equipment failed for key %s!", air_interface_capabilities_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_typeOfEquipment,
									airInterfaceCapabilityList_val,
									&typeOfEquipment_val,
									type_of_equipment);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_typeOfEquipment);

	/*
	 * Create supportedChannelPlans leaf
	 */
	val_value_t*		supportedChannelPlans_val;

	xmlChar* supported_channel_plans;
	res = cb_get_air_interface_capabilities_supported_channel_plans(air_interface_capabilities_key, &supported_channel_plans);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_supported_channel_plans failed for key %s!", air_interface_capabilities_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_supportedChannelPlans,
									airInterfaceCapabilityList_val,
									&supportedChannelPlans_val,
									supported_channel_plans);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_supportedChannelPlans);

	/*
	 * Create txFrequencyMin  leaf
	 */
	val_value_t*		txFrequencyMin_val;

	xmlChar* tx_frequency_min;
	res = cb_get_air_interface_capabilities_tx_frequency_min(air_interface_capabilities_key, &tx_frequency_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_tx_frequency_min failed for key %s!", air_interface_capabilities_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_txFrequencyMin,
									airInterfaceCapabilityList_val,
									&txFrequencyMin_val,
									tx_frequency_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_txFrequencyMin);

	/*
	 * Create txFrequencyMax  leaf
	 */
	val_value_t*		txFrequencyMax_val;

	xmlChar* tx_frequency_max;
	res = cb_get_air_interface_capabilities_tx_frequency_max(air_interface_capabilities_key, &tx_frequency_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_tx_frequency_max failed for key %s!", air_interface_capabilities_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_txFrequencyMax,
									airInterfaceCapabilityList_val,
									&txFrequencyMax_val,
									tx_frequency_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_txFrequencyMax);

	/*
	 * Create rxFrequencyMin  leaf
	 */
	val_value_t*		rxFrequencyMin_val;

	xmlChar* rx_frequency_min;
	res = cb_get_air_interface_capabilities_rx_frequency_min(air_interface_capabilities_key, &rx_frequency_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_rx_frequency_min failed for key %s!", air_interface_capabilities_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_rxFrequencyMin,
									airInterfaceCapabilityList_val,
									&rxFrequencyMin_val,
									rx_frequency_min);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_rxFrequencyMin);

	/*
	 * Create rxFrequencyMax leaf
	 */
	val_value_t*		rxFrequencyMax_val;

	xmlChar* rx_frequency_max;
	res = cb_get_air_interface_capabilities_rx_frequency_max(air_interface_capabilities_key, &rx_frequency_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_rx_frequency_max failed for key %s!", air_interface_capabilities_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_rxFrequencyMax,
									airInterfaceCapabilityList_val,
									&rxFrequencyMax_val,
									rx_frequency_max);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_rxFrequencyMax);

	/*
	 * Create adaptiveModulationIsAvail leaf
	 */
	val_value_t*		adaptiveModulationIsAvail_val;

	xmlChar* adaptive_modulation_is_available;
	res = cb_get_air_interface_capabilities_adaptive_modulation_is_available(air_interface_capabilities_key, &adaptive_modulation_is_available);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_air_interface_capabilities_adaptive_modulation_is_available failed for key %s!", air_interface_capabilities_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_adaptiveModulationIsAvail,
									airInterfaceCapabilityList_val,
									&adaptiveModulationIsAvail_val,
									adaptive_modulation_is_available);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_adaptiveModulationIsAvail);

	/*
	 * Create scriptList list elements
	 */
	res = attach_air_interface_capabilities_script_list(airInterfaceCapabilityList_val);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not attach the script list for the air interface capability list!");

	return NO_ERR;
}

static status_t attach_air_interface_current_problems_list(val_value_t *parent_val, const xmlChar* air_interface_pac_key)
{
	status_t 			res = NO_ERR;

	xmlChar* air_interface_current_problem_list[MAX_NUMBER_OF_PROBLEMS];
	int num_of_problems;
	int i;

	/*
	 * Create airInterfaceCurrentProblemList container
	 */

	val_value_t			*air_interface_current_problem_val;
	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
			y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceCurrentProblemList,
									parent_val,
									&air_interface_current_problem_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!",
			y_MicrowaveModel_ObjectClasses_MwConnection_N_airInterfaceCurrentProblemList);

	res = cb_get_all_air_interface_current_problems_for_layer_protocol_key(air_interface_pac_key, &air_interface_current_problem_list, &num_of_problems);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not cb_get_all_air_interface_current_problems!");

	for (i=0; i<num_of_problems; ++i)
	{
		/*
		 * Create problemList leaf-list entry
		 */
		val_value_t			*problem_list_val;
		res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
										y_MicrowaveModel_ObjectClasses_MwConnection_N_problemList,
										air_interface_current_problem_val,
										&problem_list_val,
										air_interface_current_problem_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!",
				y_MicrowaveModel_ObjectClasses_MwConnection_N_problemList);
	}

	return NO_ERR;
}

static status_t attach_air_interface_pac_element_to_running_config(cfg_template_t* runningcfg, const xmlChar* air_interface_pac_key)
{
	status_t 			res = NO_ERR;

	/*
	 * Create MW_AirInterface_Pac list element
	 */
	ncx_module_t *MicrowaveModel_ObjectClasses_MwConnection_mod = NULL;
	MicrowaveModel_ObjectClasses_MwConnection_mod = ncx_find_module(
		y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
		y_MicrowaveModel_ObjectClasses_MwConnection_R_MicrowaveModel_ObjectClasses_MwConnection);
	YUMA_ASSERT(MicrowaveModel_ObjectClasses_MwConnection_mod == NULL, return SET_ERROR(ERR_NCX_OPERATION_FAILED),
			"y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection not found!");

	obj_template_t* 	mw_airInterface_pac_obj;
	val_value_t*		mw_airInterface_pac_val;

	mw_airInterface_pac_obj = ncx_find_object(
			MicrowaveModel_ObjectClasses_MwConnection_mod,
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_AirInterface_Pac);
	YUMA_ASSERT(mw_airInterface_pac_obj == NULL, return SET_ERROR(ERR_NCX_DEF_NOT_FOUND), "Object %s not found!",
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_AirInterface_Pac);

	mw_airInterface_pac_val = val_new_value();
	YUMA_ASSERT(mw_airInterface_pac_val == NULL, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create value for element %s!",
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_AirInterface_Pac);

	val_init_from_template(mw_airInterface_pac_val,	mw_airInterface_pac_obj);

	val_add_child(mw_airInterface_pac_val, runningcfg->root);

	/*
	 * Create layerProtocol leaf with the value being the key passed as a parameter
	 */
	val_value_t			*layer_protocol_val;
	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_layerProtocol,
									mw_airInterface_pac_val,
									&layer_protocol_val,
									air_interface_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_layerProtocol);

	/*
	 * Create airInterfaceCapabilities list elements
	 *
	 */

	xmlChar* air_interface_capability_key_list[MAX_NUMBER_OF_AIR_INTERFACE_CAPABILITY_LIST_KEYS];
	int num_of_keys;

	res = cb_get_all_air_interface_capability_keys_for_layer_protocol(air_interface_pac_key, air_interface_capability_key_list, &num_of_keys);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL),
			"Could not cb_get_all_air_interface_capability_keys_for_layer_protocolfor layerProtocol=%s!", air_interface_pac_key);

	for (int i=0; i<num_of_keys; ++i)
	{
		res = add_air_interface_capabilities_entry(mw_airInterface_pac_val, air_interface_capability_key_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not add interface capabilities entry!");
	}

	/*
	 * Create airInterfaceConfiguration container
	 */
	res = attach_air_interface_configuration_element_for_key(mw_airInterface_pac_val, air_interface_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create air interface configuration element for key %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_layerProtocol);

	/*
	 * Create airInterfaceStatus container
	 */
	res = MicrowaveModel_ObjectClasses_MwConnection_MW_AirInterface_Pac_mro(mw_airInterface_pac_val);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create air interface status element!");

	/*
	 * Create airInterfaceCurrentProblemList container
	 */
	res = attach_air_interface_current_problems_list(mw_airInterface_pac_val, air_interface_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create air interface capabilities element!");

	YUMA_ASSERT(TRUE, NOP, "Added MW_AirInterface_Pac element having the key %s", air_interface_pac_key);

	return NO_ERR;
}

static status_t add_structure_status_time_slot_status_list_entry(val_value_t* parent_val, xmlChar* air_structure_status_time_slot_status_key_list)
{
	status_t 			res = NO_ERR;

	/*
	 * Create timeSlotStatusList list element
	 */
	val_value_t*		timeSlotStatusList_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotStatusList,
									parent_val,
									&timeSlotStatusList_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotStatusList);

	/*
	 * Create structureID leaf
	 */
	val_value_t*		structureID_val;

	xmlChar* structure_id;
	res = cb_get_structure_status_time_slot_status_list_structure_id(air_structure_status_time_slot_status_key_list, &structure_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_structure_status_time_slot_status_list_structure_id failed for key %s!", air_structure_status_time_slot_status_key_list);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_structureID,
									timeSlotStatusList_val,
									&structureID_val,
									structure_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_structureID);

	/*
	 * Create timeSlotID leaf
	 */
	val_value_t*		timeSlotID_val;

	xmlChar* time_slot_id;
	res = cb_get_structure_status_time_slot_status_list_time_slot_id(air_structure_status_time_slot_status_key_list, &time_slot_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_structure_status_time_slot_status_list_time_slot_id failed for key %s!", air_structure_status_time_slot_status_key_list);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotID,
									timeSlotStatusList_val,
									&timeSlotID_val,
									time_slot_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotID);

	/*
	 * Create operationalStatus leaf
	 */
	val_value_t*		operationalStatus_val;

	xmlChar* operational_status;
	res = cb_get_structure_status_time_slot_status_list_operational_status(air_structure_status_time_slot_status_key_list, &operational_status);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_structure_status_time_slot_status_list_operational_status failed for key %s!", air_structure_status_time_slot_status_key_list);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_operationalStatus,
									timeSlotStatusList_val,
									&operationalStatus_val,
									operational_status);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_operationalStatus);


	return NO_ERR;
}

static status_t attach_structure_configuration_element_for_key(val_value_t *parent_val, const xmlChar* structure_pac_key)
{
	status_t res = NO_ERR;

	/*
	 * Create structureConfiguration container
	 */
	val_value_t*		structureConfiguration_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_structureConfiguration,
									parent_val,
									&structureConfiguration_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_structureConfiguration);

	/*
	 * Create serverID leaf
	 */
	val_value_t*		serverId_val;

	xmlChar* server_id;
	res = cb_get_structure_configuration_server_id(structure_pac_key, &server_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_structure_configuration_server_id failed for key %s!", structure_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_serverID,
									structureConfiguration_val,
									&serverId_val,
									server_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_serverID);

	return NO_ERR;
}

static status_t attach_structure_pac_element_to_running_config(cfg_template_t* runningcfg, const xmlChar* structure_pac_key)
{
	status_t res = NO_ERR;

	/*
	 * Create MW_Structure_Pac container
	 */
	ncx_module_t *MicrowaveModel_ObjectClasses_MwConnection_mod = NULL;
	MicrowaveModel_ObjectClasses_MwConnection_mod = ncx_find_module(
		y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
		y_MicrowaveModel_ObjectClasses_MwConnection_R_MicrowaveModel_ObjectClasses_MwConnection);
	YUMA_ASSERT(MicrowaveModel_ObjectClasses_MwConnection_mod == NULL, return SET_ERROR(ERR_NCX_OPERATION_FAILED),
			"y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection not found!");

	obj_template_t* 	mw_structure_pac_obj;
	val_value_t*		mw_structure_pac_val;

	mw_structure_pac_obj = ncx_find_object(
			MicrowaveModel_ObjectClasses_MwConnection_mod,
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_Structure_Pac);
	YUMA_ASSERT(mw_structure_pac_obj == NULL, return SET_ERROR(ERR_NCX_DEF_NOT_FOUND), "Object %s not found!",
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_Structure_Pac);

	mw_structure_pac_val = val_new_value();
	YUMA_ASSERT(mw_structure_pac_val == NULL, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create value for object %s!",
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_Structure_Pac);

	val_init_from_template(mw_structure_pac_val, mw_structure_pac_obj);

	val_add_child(mw_structure_pac_val, runningcfg->root);

	/*
	 * Create layerProtocol element
	 */
	val_value_t			*layer_protocol_val;
	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_layerProtocol,
									mw_structure_pac_val,
									&layer_protocol_val,
									structure_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_layerProtocol);

	/*
	 * Create structureCapability element
	 */
	res = MicrowaveModel_ObjectClasses_MwConnection_MW_Structure_Pac_mro(mw_structure_pac_val);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create structureCapability element!");

	/*
	 * Create structureConfiguration element
	 */
	res = attach_structure_configuration_element_for_key(mw_structure_pac_val, structure_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create structureConfiguration element!");

	/*
	 * Create structureStatus element
	 */
	val_value_t			*structure_status_val;
	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_structureStatus,
									mw_structure_pac_val,
									&structure_status_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_structureStatus);


	xmlChar* air_structure_status_time_slot_status_key_list[MAX_NUMBER_OF_TIME_SLOTS];
	int num_of_time_slots;
    int i;

    /*
	 * Create timeSlotStatusList element for each of the available keys
	 */
	res = cb_get_all_structure_status_time_slot_status_keys_for_layer_protocol_key(structure_pac_key, &air_structure_status_time_slot_status_key_list, &num_of_time_slots);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL),
			"Could not cb_get_all_structure_status_time_slot_status_keys_for_layer_protocol_key for layerProtocol=%s!", structure_pac_key);

	for (i=0; i<num_of_time_slots; ++i)
	{
		res = add_structure_status_time_slot_status_list_entry(structure_status_val, air_structure_status_time_slot_status_key_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not add structure status time slot status list entry!");
	}

	YUMA_ASSERT(TRUE, NOP, "Added MW_Structure_pac_element with key %s!", structure_pac_key);

	return NO_ERR;
}

static status_t add_available_kind_of_containers_list_entry(val_value_t* parent_val, xmlChar* container_type_key)
{
	status_t 			res = NO_ERR;

	/*
	 * Create availableKindsOfContainerList element
	 */
	val_value_t*		available_kinds_of_container_list_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_availableKindsOfContainerList,
									parent_val,
									&available_kinds_of_container_list_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_availableKindsOfContainerList);


	/*
	 * Create Container Type uuid leaf
	 */
	val_value_t*		uuid_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_uuid,
									available_kinds_of_container_list_val,
									&uuid_val,
									container_type_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_uuid);

	/*
	 * Create containerName leaf
	 */
	val_value_t*		containerName_val;

	xmlChar* container_name;
	res = cb_get_container_capability_container_name(container_type_key, &container_name);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_container_name failed for key %s!", container_type_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_containerName,
									available_kinds_of_container_list_val,
									&containerName_val,
									container_name);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_containerName);

	/*
	 * Create numberOfTimeSlotsRequired leaf
	 */
	val_value_t*		numberOfTimeSlotsRequired_val;

	xmlChar* number_of_time_slots_required;
	res = cb_get_container_capability_number_of_time_slots_required(container_type_key, &number_of_time_slots_required);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_number_of_time_slots_required failed for key %s!", container_type_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_numberOfTimeSlotsRequired,
									available_kinds_of_container_list_val,
									&numberOfTimeSlotsRequired_val,
									number_of_time_slots_required);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_numberOfTimeSlotsRequired);

	/*
	 * Create bundlingIsAvail leaf
	 */
	val_value_t*		bundlingIsAvail_val;

	xmlChar* bundling_is_avail;
	res = cb_get_container_capability_bundling_is_avail(container_type_key, &bundling_is_avail);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_bundling_is_avail failed for key %s!", container_type_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_bundlingIsAvail,
									available_kinds_of_container_list_val,
									&bundlingIsAvail_val,
									bundling_is_avail);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_bundlingIsAvail);

	return NO_ERR;
}

static status_t attach_container_capability_element(val_value_t *parent_val, const xmlChar* container_pac_key)
{
	status_t res = NO_ERR;

	/*
	 * Create containerCapability container
	 */
	val_value_t*		containerCapability_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_containerCapability,
									parent_val,
									&containerCapability_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_containerCapability);

	/*
	 * Create containerID leaf
	 */
	val_value_t*		containerID_val;

	xmlChar* container_id;
	res = cb_get_container_capability_container_id(container_pac_key, &container_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_container_id failed for key %s!", container_pac_key);


	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_containerID,
									containerCapability_val,
									&containerID_val,
									container_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_containerID);

	xmlChar* container_type_key_list[MAX_NUMBER_OF_CONTAINER_TYPE_KEYS];
	int num_of_keys;
	int i;

	/*
	 * Create availableKindsOfContainers container
	 */
	res = cb_get_all_container_capabilities_available_kinds_of_containers_keys_for_layer_protocol_key(container_pac_key, &container_type_key_list, &num_of_keys);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL),
			"Could not cb_get_all_container_capabilities_available_kinds_of_containers_keys_for_layer_protocol_key for layerProtocol=%s!", container_pac_key);

	for (i=0; i<num_of_keys; ++i)
	{
		res = add_available_kind_of_containers_list_entry(containerCapability_val, container_type_key_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not add available kind of containers list entry!");
	}

	return NO_ERR;
}

static status_t add_container_config_time_slot_id_list(val_value_t* parent_val, xmlChar* container_config_time_slot_id_key)
{
	status_t 			res = NO_ERR;

	/*
	 * Create timeSlotIDList list entry
	 */
	val_value_t*		time_slot_id_list_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotIDList,
									parent_val,
									&time_slot_id_list_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotIDList);

	/*
	 * Create structureID leaf
	 */
	val_value_t*		structure_id_val;

	xmlChar* structure_id;
	res = cb_get_container_config_structure_id(container_config_time_slot_id_key, &structure_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_config_structure_id failed for key %s!", container_config_time_slot_id_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_structureID,
									time_slot_id_list_val,
									&structure_id_val,
									structure_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_structureID);

	/*
	 * Create timeSlotID leaf
	 */
	val_value_t*		time_slot_id_val;

	xmlChar* time_slot_id;
	res = cb_get_container_config_time_slot_id(container_config_time_slot_id_key, &time_slot_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_config_time_slot_id failed for key %s!", container_config_time_slot_id_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotID,
									time_slot_id_list_val,
									&time_slot_id_val,
									time_slot_id);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_timeSlotID);

	return NO_ERR;
}

static status_t attach_container_configuration_element(val_value_t *parent_val, const xmlChar* container_pac_key)
{
	status_t res = NO_ERR;

	/*
	 * Create containerConfiguration container
	 */
	val_value_t*		container_configuration_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_containerConfiguration,
									parent_val,
									&container_configuration_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_containerConfiguration);

	/*
	 * Create container container
	 */
	val_value_t*		container_val;

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_container,
									container_configuration_val,
									&container_val,
									NULL);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_container);

	/*
	 * Create Container Type uuid leaf
	 */
	val_value_t*		uuid_val;

	xmlChar* uuid;
	res = cb_get_container_configuration_uuid(container_pac_key, &uuid);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_uuid failed for key %s!", container_pac_key);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_uuid,
									container_val,
									&uuid_val,
									uuid);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_uuid);

	/*
	 * Create containerName leaf
	 */
	val_value_t*		containerName_val;

	xmlChar* container_name;
	res = cb_get_container_capability_container_name(uuid, &container_name);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_container_name failed for key %s!", uuid);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_containerName,
									container_val,
									&containerName_val,
									container_name);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_containerName);

	/*
	 * Create numberOfTimeSlotsRequired leaf
	 */
	val_value_t*		numberOfTimeSlotsRequired_val;

	xmlChar* number_of_time_slots_required;
	res = cb_get_container_capability_number_of_time_slots_required(uuid, &number_of_time_slots_required);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_number_of_time_slots_required failed for key %s!", uuid);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_numberOfTimeSlotsRequired,
									container_val,
									&numberOfTimeSlotsRequired_val,
									number_of_time_slots_required);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_numberOfTimeSlotsRequired);

	/*
	 * Create bundlingIsAvail leaf
	 */
	val_value_t*		bundlingIsAvail_val;

	xmlChar* bundling_is_avail;
	res = cb_get_container_capability_bundling_is_avail(uuid, &bundling_is_avail);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_container_capability_bundling_is_avail failed for key %s!", uuid);

	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_bundlingIsAvail,
									container_val,
									&bundlingIsAvail_val,
									bundling_is_avail);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_bundlingIsAvail);

	/*
	 * Create timeSlotIDList list element
	 */
	xmlChar* config_time_slot_id_key_list[MAX_NUMBER_OF_CONTAINER_CONFIG_TIME_SLOT_ID_KEYS];
	int num_of_keys;
	int i;

	res = cb_get_container_configuration_time_slot_id_keys_for_layer_protocol_key(container_pac_key, &config_time_slot_id_key_list, &num_of_keys);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL),
			"Could not cb_get_container_configuration_time_slot_id_keys_for_layer_protocol_key for layerProtocol=%s!", container_pac_key);

	for (i=0; i<num_of_keys; ++i)
	{
		res = add_container_config_time_slot_id_list(container_configuration_val, config_time_slot_id_key_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not add containerConfigure time slot list having the key %s", container_pac_key);
	}

	return NO_ERR;
}

static status_t attach_container_pac_element_to_running_config(cfg_template_t* runningcfg, const xmlChar* container_pac_key)
{
	status_t res = NO_ERR;

	/*
	 * Create MW_Container_Pac container
	 */
	ncx_module_t *MicrowaveModel_ObjectClasses_MwConnection_mod = NULL;
	MicrowaveModel_ObjectClasses_MwConnection_mod = ncx_find_module(
		y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
		y_MicrowaveModel_ObjectClasses_MwConnection_R_MicrowaveModel_ObjectClasses_MwConnection);
	YUMA_ASSERT(MicrowaveModel_ObjectClasses_MwConnection_mod == NULL, return SET_ERROR(ERR_NCX_OPERATION_FAILED),
			"y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection not found!");

	obj_template_t* 	mw_container_pac_obj;
	val_value_t*		mw_container_pac_val;

	mw_container_pac_obj = ncx_find_object(
			MicrowaveModel_ObjectClasses_MwConnection_mod,
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_Container_Pac);
	YUMA_ASSERT(mw_container_pac_obj == NULL, return SET_ERROR(ERR_NCX_DEF_NOT_FOUND), "Object %s not found!",
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_Container_Pac);

	mw_container_pac_val = val_new_value();
	YUMA_ASSERT(mw_container_pac_val == NULL, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create value for object %s!",
			y_MicrowaveModel_ObjectClasses_MwConnection_N_MW_Container_Pac);

	val_init_from_template(mw_container_pac_val, mw_container_pac_obj);

	val_add_child(mw_container_pac_val, runningcfg->root);

	/*
	 * Create layerProtocol element
	 */
	val_value_t			*layer_protocol_val;
	res = u_find_and_init_child_obj(y_MicrowaveModel_ObjectClasses_MwConnection_M_MicrowaveModel_ObjectClasses_MwConnection,
									y_MicrowaveModel_ObjectClasses_MwConnection_N_layerProtocol,
									mw_container_pac_val,
									&layer_protocol_val,
									container_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "u_create_and_init_child_obj failed for %s!", y_MicrowaveModel_ObjectClasses_MwConnection_N_layerProtocol);

	/*
	 * Create containerCapability element
	 */
	res = attach_container_capability_element(mw_container_pac_val, container_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create containerCapability element!");

	/*
	 * Create containerConfiguration element
	 */
	res = attach_container_configuration_element(mw_container_pac_val, container_pac_key);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create containerConfiguration element!");

	/*
	 * Create containerStatus element
	 */
	res = MicrowaveModel_ObjectClasses_MwConnection_MW_Container_Pac_mro(mw_container_pac_val);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "Could not create containerStatus element!");

	YUMA_ASSERT(TRUE, NOP, "Added MW_Container_pac_element with key %s!", container_pac_key);

	return NO_ERR;
}

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_MicrowaveModel_ObjectClasses_MwConnection_init2 (void)
{
    status_t res = NO_ERR;
    xmlChar* air_interface_pac_keys_list[MAX_NUMBER_OF_AIR_INTERFACE_PAC];
    int num_of_air_interface_pac_keys;
    xmlChar* structure_pac_keys_list[MAX_NUMBER_OF_STRUCTURE_PAC];
	int num_of_structure_pac_keys;
    xmlChar* container_pac_keys_list[MAX_NUMBER_OF_CONTAINER_PAC];
	int num_of_container_pac_keys;
	int i;

    cfg_template_t* runningcfg;
	runningcfg = cfg_get_config_id(NCX_CFGID_RUNNING);
	YUMA_ASSERT(!runningcfg || !runningcfg->root, return SET_ERROR(ERR_INTERNAL_VAL), "No running config available in u_MicrowaveModel_ObjectClasses_MwConnection_init2!");

	/*
	 * Create all MW_AirInterface_Pac elements
	 */
	res = cb_get_all_air_interface_pac_keys(air_interface_pac_keys_list, &num_of_air_interface_pac_keys);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_all_air_interface_pac_keys failed!");

	for (i=0; i<num_of_air_interface_pac_keys; ++i)
	{
		res = attach_air_interface_pac_element_to_running_config(runningcfg, air_interface_pac_keys_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "attach_air_interface_pac_element_to_running_config failed!");
	}

	/*
	 * Create all MW_Structure_Pac elements
	 */

	res = cb_get_all_structure_pac_keys(structure_pac_keys_list, &num_of_structure_pac_keys);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_all_structure_pac_keys failed!");

	for (i=0; i<num_of_structure_pac_keys; ++i)
	{
		res = attach_structure_pac_element_to_running_config(runningcfg, structure_pac_keys_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "attach_structure_pac_element_to_running_config failed!");
	}

	/*
	 * Create all MW_Container_Pac elements
	 */

	res = cb_get_all_container_pac_keys(container_pac_keys_list, &num_of_container_pac_keys);
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cb_get_all_container_pac_keys failed!");

	for (i=0; i<num_of_container_pac_keys; ++i)
	{
		res = attach_container_pac_element_to_running_config(runningcfg, container_pac_keys_list[i]);
		YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "attach_container_pac_element_to_running_config failed!");
	}

	/*
	 * Copy the  running configuration to the candidate configuration
	 */
	res = cfg_fill_candidate_from_running();
	YUMA_ASSERT(res != NO_ERR, return SET_ERROR(ERR_INTERNAL_VAL), "cfg_fill_candidate_from_running failed!");

    return res;
} /* u_MicrowaveModel_ObjectClasses_MwConnection_init2 */

/********************************************************************
* FUNCTION u_MicrowaveModel_ObjectClasses_MwConnection_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void u_MicrowaveModel_ObjectClasses_MwConnection_cleanup (void)
{
    /* put your cleanup code here */
    
} /* u_MicrowaveModel_ObjectClasses_MwConnection_cleanup */

/* END u_MicrowaveModel_ObjectClasses_MwConnection.c */
